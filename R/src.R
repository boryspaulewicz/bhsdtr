## -*- coding: utf-8 -*-

## TODO: poprawne parsowanie group = ~ id dla id będącego zmienną nienumeryczną

rmatch = function (pattern, vector){
  res = TRUE
  for (i in 1:length(vector)) {
    if (length(grep(pattern, vector[i])) > 0) {
      res[i] = TRUE
    }
    else {
      res[i] = FALSE
    }
  }
  res
}

remove.zero.cols = function(m)as.matrix(m[,apply(m, 2, function(x)!all(x == 0))])

fix_stan_dim = function(x)if(length(x) == 1){ array(x, dim = 1) }else{ x }

#' Calculates delta = log(d') assuming an unbiased observer and p(stim = 1) = 0.5
#' @param acc average accuracy
#' @return delta = log(d')
#' @export
acc_to_delta = function(acc)log(2 * stats::qnorm(acc))

#' Transforms gamma posterior samples to midpoint centered criteria
#' @param samples Posterior samples from stanfit object, e.g., samples = as.data.frame(stanfit)
#' @param beta_index Fixed effect index
#' @param s Scaling factor used in the model
#' @export
gamma_to_crit = function(samples, beta_index = 1, s = 2){
    if(length(beta_index) != 1)
        warning("Using only the first element of the beta_index vector")
    nms = grep(sprintf('gamma_fixed\\[[0-9]+,%d]', beta_index[1]), names(samples))
    if(length(nms) == 0)
        stop(sprintf("Could not find gamma_fixed[,%d] samples", beta_index))
    crit = t(apply(exp(cbind(samples[, nms], 0)), 1, function(x)s * qnorm(cumsum(x / sum(x))[-length(x)])))
    colnames(crit) = gsub('gamma', 'criteria', colnames(crit))
    crit
}

#' Calculates combined response given the information about the stimulus, rating and accuracy or decision
#' @export
combined_response = function(stimulus, rating, accuracy = NULL, decision = NULL){
  ## 0/1 coding
  stimulus = as.numeric(as.factor(as.character(stimulus))) - 1
  if(is.null(decision)){
    if(is.null(decision) && is.null(accuracy))
        stop("Neither decision nor accuracy data provided")
        decision = accuracy * stimulus + (1 - accuracy) * (1 - stimulus)
  }else{
    decision = as.numeric(as.factor(as.character(decision))) - 1
  }
  rating = as.numeric(as.factor(rating))
  rating = rating - min(rating, na.rm = T) + 1
  max.rating = max(rating, na.rm = T)
  (1 - decision) * (max.rating + 1 - rating) + decision * (max.rating + rating)
}

#' Creates the aggregated data object needed by other functions.
#'
#' \code{aggregate_responses} aggregates combined or binary responses
#' as response counts matrix and stores them in the list together with
#' additional variables and the stimulus variable.
#'
#' This function produces a data object that is needed by the 
#' 
#' @export
aggregate_responses = function(data, stimulus, response, variables){
  ## stimulus classes encoded as 1 or 2
  data[[stimulus]] = as.numeric(as.factor(as.character(data[[stimulus]])))
  K = max(data[[response]], na.rm = T)
  res = plyr::ddply(data, unique(c(variables, stimulus)), function(df)table(c(df[[response]], 1:K)) - 1)
  counts = res[, c((ncol(res)-K+1):ncol(res))]
  list(data = res[, setdiff(variables, stimulus)], stimulus = res[[stimulus]], counts = counts)
}

## A helper function, makes sure the prior specification is correct
parse_prior = function(value = NULL, default, dims, name){
  if(is.null(value)){
    if(length(dims) == 1){
      value = rep(default, dims)
    }else{
      value = matrix(default, nrow = dims[1], ncol = dims[2])
    }
  }else{
    if(length(value) == 1){
      if(length(dims) == 1){
        value = rep(value, dims)
      }else{
        value = matrix(value, nrow = dims[1], ncol = dims[2])
      }
    }else{
      if(length(value) != prod(dims))
        stop(sprintf("Prior specification %s must contain 1 or %d elements", name, dims))
    }
  }
  fix_stan_dim(value)
}

#' Creates a list of data structures required by Stan to fit the SDT model generated by make_stan_model.
#' @export
make_stan_data = function(stimulus, counts, fixed, extra_data = t(rep(1, nrow(counts))),
                          random = list(), criteria_scale = 2){
  K = ncol(counts)
  if(length(random) > 0){
    for(l in 1:length(random)){
      group.mm = stats::model.matrix(random[[l]]$group, extra_data)
      if(ncol(group.mm) == 2){
        ## Probably a numeric variable
        random[[l]]$group = as.numeric(as.factor(as.character(group.mm[,2])))
      }else{
        ## Probably a factor
        group.mm = remove.zero.cols(group.mm)
        random[[l]]$group = (group.mm %*% 1:(ncol(group.mm)))[,1]
      }
    }
  }
  X_delta = remove.zero.cols(stats::model.matrix(fixed$delta, extra_data))
  X_gamma = remove.zero.cols(stats::model.matrix(fixed$gamma, extra_data))
  data = list(N = nrow(X_delta),
              K = K,
              X_delta_ncol = ncol(X_delta),
              X_delta = X_delta,
              X_gamma_ncol = ncol(X_gamma),
              X_gamma = X_gamma,
              criteria_scale = criteria_scale,
              stim_sign = 2 * as.numeric(as.factor(as.character(stimulus))) - 3,
              counts = counts)
  ## Priors
  data$delta_fixed_mu = parse_prior(fixed$delta_mu, acc_to_delta(.75), ncol(X_delta), 'delta_mu')
  data$delta_fixed_sd = parse_prior(fixed$delta_sd, .5 * (acc_to_delta(.99) - acc_to_delta(.51)), ncol(X_delta), 'delta_sd')
  data$gamma_fixed_mu = parse_prior(fixed$gamma_mu, 0, c(K - 1, ncol(X_gamma)), 'gamma_mu')
  data$gamma_fixed_sd = parse_prior(fixed$gamma_sd, log(100), c(K - 1, ncol(X_gamma)), 'gamma_sd')
  ## Random effects
  if(length(random) > 0){
    for(l in 1:length(random)){
      data[[sprintf('G_%d', l)]] = max(random[[l]]$group)
      data[[sprintf('group_%d', l)]] = random[[l]]$group
      if(!is.null(random[[l]]$delta)){
        mm = remove.zero.cols(stats::model.matrix(random[[l]]$delta, extra_data))
        data[[sprintf('Z_delta_ncol_%d', l)]] = ncol(mm)
        data[[sprintf('Z_delta_%d', l)]] = mm
        data[[sprintf('lkj_delta_nu_%d', l)]] = if(is.null(random[[l]]$delta_nu)){ 1 }else{ random[[l]]$delta_nu }
        if(is.null(random[[l]]$delta_scale)){
          delta_sd_scale = rep(.5 * (acc_to_delta(.99) - acc_to_delta(.51)), ncol(mm))
        }else{
          if(length(random[[l]]$delta_scale) == 1){
            delta_sd_scale = rep(random[[l]]$delta_scale[1], ncol(mm))
          }else{
            delta_sd_scale = random[[l]]$delta_scale
          }
        }
        data[[sprintf('delta_sd_scale_%d', l)]] = fix_stan_dim(delta_sd_scale)
      }
      if(!is.null(random[[l]]$gamma)){
        mm = remove.zero.cols(stats::model.matrix(random[[l]]$gamma, extra_data))
        data[[sprintf('Z_gamma_ncol_%d', l)]] = ncol(mm)
        data[[sprintf('Z_gamma_%d', l)]] = mm
        data[[sprintf('lkj_gamma_nu_%d', l)]] = if(is.null(random[[l]]$gamma_nu)){ 1 }else{ random[[l]]$gamma_nu }
        if(is.null(random[[l]]$gamma_scale)){
          gamma_sd_scale = rep(log(100), (K - 1) * ncol(mm))
        }else{
          if(length(random[[l]]$gamma_scale) == 1){
            gamma_sd_scale = rep(random[[l]]$gamma_scale[1], (K - 1) * ncol(mm))
          }else{
            gamma_sd_scale = random[[l]]$gamma_scale
          }
        }
        data[[sprintf('gamma_sd_scale_%d', l)]] = fix_stan_dim(gamma_sd_scale)
      }
    }
  }
  data
}

#' Creates Stan model code describing the SDT model based on a given
#' random effects specification.
#' @export
make_stan_model = function(random = list()){
  model = ''
  f = file(paste(path.package('bhsdtr'), '/stan_templates/sdt_template.stan', sep = ''))
  for(part in readLines(f)){
    ## Jeżeli to jest fragment dotyczący efektów losowych ...
    if(rmatch('//(common|delta|gamma)', part)){
      ## ... i w ogóle modelujemy efekty losowe ...
      if(length(random) > 0)
        for(l in 1:length(random)){
          ## ... to indeksuj część wspólną ...
          if(rmatch('//common', part))
            model[length(model)+1] = gsub('%', l, part)
          ## ... i części specyficzne dla parametrów delta i
          ## gamma, o ile mają być pod wpływem czynników
          ## losowych
          for(par in c('delta', 'gamma'))
            if(!is.null(random[[l]][[par]]) & rmatch(sprintf('//%s', par), part))
              model[length(model)+1] = gsub('%', l, part)
        }
    }else{
      ## To nie jest fragment dotyczący efektów losowych, a więc
      ## kopiujemy bez zmian
      model[length(model)+1] = part
    }
  }
  close(f)
  paste(model, collapse = '\n')
}

#' Creates SDT-R model fit plots with posterior predictive intervals
#' @export
plot_sdt_fit = function(fit, adata, variables = NULL, type = 'roc', alpha = .05){
    s = as.data.frame(fit)
    rm(fit)
    cnt_new = t(s[,grep('counts_new', names(s))])
    rm(s)
    ## Tworzymy zbiór danych rozwinięty pionowo
    df = cbind(adata$data, adata$stimulus)
    names(df)[ncol(df)] = 'stimulus'
    stim = ncol(df)
    K = ncol(adata$counts)
    df = cbind(ddply(df, names(df), function(x)data.frame(1:K)), as.vector(t(adata$counts)))
    df = cbind(df, rep(1:nrow(adata$data), each = ncol(adata$counts)))
    ## Indeksy ważnych kolumn
    resp = ncol(df) - 2
    cnt = ncol(df) - 1
    obs = ncol(df)
    ## Kolejność taka, jak w próbkach ze Stan-a
    df = df[order(df[[resp]], df[[obs]]),]
    ## Agregacja obserwacji i próbek dla dowolnego wykresu
    if(length(variables) > 0){
        f = as.factor(df[[variables[1]]])
        if(length(variables) > 1)
            for(v in variables[-1])
                f = f:as.factor(df[[v]])
    }else{
        f = as.factor(rep(1, nrow(df)))
    }
    dfa = aggregate(df[[cnt]] ~ df[[resp]] + df[[stim]] + f, FUN = sum)
    cnt_new_a = matrix(nrow = ncol(cnt_new), ncol = nrow(dfa))
    pb = txtProgressBar(min = 1, max = ncol(cnt_new), style = 3)
    print('Aggregating posterior samples...')
    for(r in 1:ncol(cnt_new)){
        cnt_new_a[r,] = aggregate(cnt_new[,r] ~ df[[resp]] + df[[stim]] + f, FUN = sum)[[4]]
        setTxtProgressBar(pb, r)
    }
    close(pb)
    rm(cnt_new)
    names(dfa) = c('response', 'stimulus', 'f', 'count')
    dfa$stimulus = as.factor(dfa$stimulus)
    dfa$n = ddply(dfa, c('f', 'stimulus'), function(x)data.frame(n = rep(sum(x$count), nrow(x))))[[3]]
    dfa$i = 1:nrow(dfa)
    if(type == 'roc'){
        ## Wykres ROC: wyliczamy p(Hit) ~ p(FA)
        print('Calculating ROC curves...')
        dfroc = ddply(dfa, c('stimulus', 'f'),
                      function(x){
                          cumfr_new = apply(t(cnt_new_a[,x$i]), 2, function(v)rev(cumsum(rev(v / x$n))))
                          data.frame(response = x$response,
                                     cumfr = rev(cumsum(rev(x$count / x$n))),
                                     cumfr.fit = apply(cumfr_new, 1, mean),
                                     cumfr.lo = apply(cumfr_new, 1, function(x)quantile(x, alpha / 2)),
                                     cumfr.hi = apply(cumfr_new, 1, function(x)quantile(x, 1 - alpha / 2)))
                      }, .progress = 'text')
        rm(dfa)
        ## dfroc$in.pi = as.numeric((dfroc$cumfr >= dfroc$cumfr.lo) && (dfroc$cumfr <= dfroc$cumfr.hi))
        ## dfroc$in.pi[dfroc$in.pi == 0] = .5
        dfrocs = dfroc[dfroc$stimulus == '1',]
        dfrocs$stim2 = dfroc[dfroc$stimulus == '2',]
        rm(dfroc)
        ggplot(dfrocs, aes(cumfr, stim2$cumfr)) + 
            geom_line(aes(x = cumfr.fit, y = stim2$cumfr.fit), lty = 2) + 
            geom_errorbar(aes(ymin = stim2$cumfr.lo, ymax = stim2$cumfr.hi, x = cumfr.fit), width = 0.02) +
            geom_errorbarh(aes(xmin = cumfr.lo, xmax = cumfr.hi, y = stim2$cumfr.fit), height = 0.02) +
            geom_point() +
            labs(x = 'p(Hit)', y = 'p(FA)') +
            coord_fixed() +
            facet_wrap(~f)
    }else{
        ## Wykres rozkładów odpowiedzi
        dfa[,c('count.lo', 'count.hi', 'count.fit')] = cbind(apply(cnt_new_a, 2, function(x)quantile(x, alpha / 2)),
                                                             apply(cnt_new_a, 2, function(x)quantile(x, 1 - alpha / 2)),
                                                             apply(cnt_new_a, 2, mean))
        ggplot(dfa, aes(response, count / n, color = stimulus), group = stimulus) +
            geom_errorbar(aes(ymin = count.lo / n, ymax = count.hi / n, lty = stimulus), width = 0.2) +
            geom_line(aes(y = count.fit / n, lty = stimulus)) +
            geom_point(aes(pch = stimulus)) +
            labs(x = 'Response', y = 'Frequency', color = 'Stimulus', pch = 'Stimulus', lty = 'Stimulus') +
            facet_wrap(~f)
    }
}
