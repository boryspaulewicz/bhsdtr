## -*- coding: utf-8 -*-

## TODO: agregowanie counts i new_counts wg zadanej formuły, tylko na
## potrzeby wykresów dopasowania.

## TODO: wykresy, może CI na podstawie tego, co robią w pROC?

## TODO: poprawne parsowanie group = ~ id dla id będącego zmienną nienumeryczną

## TODO: funkcja do liczenia priorów dla gamma

## TODO: Progress bar do roc_points

## TODO: Priory dla delta są niesymetryczne w kilku znaczeniach -
## przemyśleć

## TODO: Sprawdzić jak radzi sobie metoda wariacyjna

## TODO: Sprawdzić normalność posteriorów

## TODO: dane benchmark


rmatch = function (pattern, vector){
  res = TRUE
  for (i in 1:length(vector)) {
    if (length(grep(pattern, vector[i])) > 0) {
      res[i] = TRUE
    }
    else {
      res[i] = FALSE
    }
  }
  res
}

remove.zero.cols = function(m)as.matrix(m[,apply(m, 2, function(x)!all(x == 0))])

fix_stan_dim = function(x)if(length(x) == 1){ array(x, dim = 1) }else{ x }

#' Calculates delta = log(d') assuming an unbiased observer and p(stim = 1) = 0.5
#' @param acc average accuracy
#' @return delta = log(d')
#' @export
acc_to_delta = function(acc)log(2 * stats::qnorm(acc))

#' Calculates combined response given the information about the stimulus, rating and accuracy or decision
#' @export
combined_response = function(stimulus, rating, accuracy = NULL, decision = NULL){
  ## 0/1 coding
  stimulus = as.numeric(as.factor(as.character(stimulus))) - 1
  if(is.null(decision)){
    if(is.null(decision) && is.null(accuracy))
        stop("Neither decision nor accuracy data provided")
        decision = accuracy * stimulus + (1 - accuracy) * (1 - stimulus)
  }else{
    decision = as.numeric(as.factor(as.character(decision))) - 1
  }
  rating = as.numeric(as.factor(rating))
  rating = rating - min(rating, na.rm = T) + 1
  max.rating = max(rating, na.rm = T)
  (1 - decision) * (max.rating + 1 - rating) + decision * (max.rating + rating)
}

#' Aggregates combined responses as response counts matrix and stores them in a list with additional variables in a data frame.
#' @export
aggregate_responses = function(data, stimulus, response, variables){
  ## stimulus classes encoded as 1 or 2
  data[[stimulus]] = as.numeric(as.factor(as.character(data[[stimulus]])))
  K = max(data[[response]], na.rm = T)
  res = plyr::ddply(data, unique(c(variables, stimulus)), function(df)table(c(df[[response]], 1:K)) - 1)
  counts = res[, c((ncol(res)-K+1):ncol(res))]
  list(data = res[, setdiff(variables, stimulus)], stimulus = res[[stimulus]], counts = counts)
}

## Make sure the prior specification is correct
parse_prior = function(value = NULL, default, dims, name){
  if(is.null(value)){
    if(length(dims) == 1){
      value = rep(default, dims)
    }else{
      value = matrix(default, nrow = dims[1], ncol = dims[2])
    }
  }else{
    if(length(value) == 1){
      if(length(dims) == 1){
        value = rep(value, dims)
      }else{
        value = matrix(value, nrow = dims[1], ncol = dims[2])
      }
    }else{
      if(length(value) != prod(dims))
        stop(sprintf("Prior specification %s must contain 1 or %d elements", name, dims))
    }
  }
  fix_stan_dim(value)
}

#' Creates a list of data structures required by Stan to fit the SDT model generated by make_stan_model.
#' @export
make_stan_data = function(stimulus, counts, fixed, extra_data = t(rep(1, nrow(counts))),
                          random = list(), criteria_scale = 2){
  K = ncol(counts)
  if(length(random) > 0){
    for(l in 1:length(random)){
      group.mm = stats::model.matrix(random[[l]]$group, extra_data)
      if(ncol(group.mm) == 2){
        ## Probably a numeric variable
        random[[l]]$group = as.numeric(as.factor(as.character(group.mm[,2])))
      }else{
        ## Probably a factor
        group.mm = remove.zero.cols(group.mm)
        random[[l]]$group = (group.mm %*% 1:(ncol(group.mm)))[,1]
      }
    }
  }
  X_delta = remove.zero.cols(stats::model.matrix(fixed$delta, extra_data))
  X_gamma = remove.zero.cols(stats::model.matrix(fixed$gamma, extra_data))
  data = list(N = nrow(X_delta),
              K = K,
              X_delta_ncol = ncol(X_delta),
              X_delta = X_delta,
              X_gamma_ncol = ncol(X_gamma),
              X_gamma = X_gamma,
              criteria_scale = criteria_scale,
              stim_sign = 2 * as.numeric(as.factor(as.character(stimulus))) - 3,
              counts = counts)
  ## Priors
  data$delta_fixed_mu = parse_prior(fixed$delta_mu, acc_to_delta(.75), ncol(X_delta), 'delta_mu')
  data$delta_fixed_sd = parse_prior(fixed$delta_sd, .5 * (acc_to_delta(.99) - acc_to_delta(.51)), ncol(X_delta), 'delta_sd')
  data$gamma_fixed_mu = parse_prior(fixed$gamma_mu, 0, c(K - 1, ncol(X_gamma)), 'gamma_mu')
  data$gamma_fixed_sd = parse_prior(fixed$gamma_sd, log(100), c(K - 1, ncol(X_gamma)), 'gamma_sd')
  ## Random effects
  if(length(random) > 0){
    for(l in 1:length(random)){
      data[[sprintf('G_%d', l)]] = max(random[[l]]$group)
      data[[sprintf('group_%d', l)]] = random[[l]]$group
      if(!is.null(random[[l]]$delta)){
        mm = remove.zero.cols(stats::model.matrix(random[[l]]$delta, extra_data))
        data[[sprintf('Z_delta_ncol_%d', l)]] = ncol(mm)
        data[[sprintf('Z_delta_%d', l)]] = mm
        data[[sprintf('lkj_delta_nu_%d', l)]] = if(is.null(random[[l]]$delta_nu)){ 1 }else{ random[[l]]$delta_nu }
        if(is.null(random[[l]]$delta_scale)){
          delta_sd_scale = rep(.5 * (acc_to_delta(.99) - acc_to_delta(.51)), ncol(mm))
        }else{
          if(length(random[[l]]$delta_scale) == 1){
            delta_sd_scale = rep(random[[l]]$delta_scale[1], ncol(mm))
          }else{
            delta_sd_scale = random[[l]]$delta_scale
          }
        }
        data[[sprintf('delta_sd_scale_%d', l)]] = fix_stan_dim(delta_sd_scale)
      }
      if(!is.null(random[[l]]$gamma)){
        mm = remove.zero.cols(stats::model.matrix(random[[l]]$gamma, extra_data))
        data[[sprintf('Z_gamma_ncol_%d', l)]] = ncol(mm)
        data[[sprintf('Z_gamma_%d', l)]] = mm
        data[[sprintf('lkj_gamma_nu_%d', l)]] = if(is.null(random[[l]]$gamma_nu)){ 1 }else{ random[[l]]$gamma_nu }
        if(is.null(random[[l]]$gamma_scale)){
          gamma_sd_scale = rep(log(100), (K - 1) * ncol(mm))
        }else{
          if(length(random[[l]]$gamma_scale) == 1){
            gamma_sd_scale = rep(random[[l]]$gamma_scale[1], (K - 1) * ncol(mm))
          }else{
            gamma_sd_scale = random[[l]]$gamma_scale
          }
        }
        data[[sprintf('gamma_sd_scale_%d', l)]] = fix_stan_dim(gamma_sd_scale)
      }
    }
  }
  data
}

#' Creates the Stan model code describing the SDT model based on a given random effects specification.
#' @export
make_stan_model = function(random = list()){
  model = ''
  f = file(paste(path.package('bhsdtr'), '/stan_templates/sdt_template.stan', sep = ''))
  for(part in readLines(f)){
    ## Jeżeli to jest fragment dotyczący efektów losowych ...
    if(rmatch('//(common|delta|gamma)', part)){
      ## ... i w ogóle modelujemy efekty losowe ...
      if(length(random) > 0)
        for(l in 1:length(random)){
          ## ... to indeksuj część wspólną ...
          if(rmatch('//common', part))
            model[length(model)+1] = gsub('%', l, part)
          ## ... i części specyficzne dla parametrów delta i
          ## gamma, o ile mają być pod wpływem czynników
          ## losowych
          for(par in c('delta', 'gamma'))
            if(!is.null(random[[l]][[par]]) & rmatch(sprintf('//%s', par), part))
              model[length(model)+1] = gsub('%', l, part)
        }
    }else{
      ## To nie jest fragment dotyczący efektów losowych, a więc
      ## kopiujemy bez zmian
      model[length(model)+1] = part
    }
  }
  close(f)
  paste(model, collapse = '\n')
}
