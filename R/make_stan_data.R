## -*- coding: utf-8 -*-

#' Creates the list of data structures required by the stan function.
#'
#' \code{make_stan_data} creates the list of data structures required by the
#' \code{stan} function when fitting the model generated by
#' \code{make_stan_model}.
#'
#' \code{fixed} must be a list of model formulae. It may also contain prior
#' parameter values, if non-default priors on fixed effects are required. This
#' list is composed of the following elements:
#'
#' \describe{
#'
#' \item{delta}{is a model formula that defines the delta fixed effects model
#' matrix, e.g., \code{delta = ~ condition}}
#'
#' \item{gamma}{is a model formula that defines the gamma fixed effects model
#' matrix.}
#'
#' \item{delta_mu}{is na optional vector specifying means of independent normal
#' priors on delta fixed effects. This must be of the same length as the number
#' of delta fixed effects or of length 1, in which case the same value will be
#' used for every delta fixed effect. The default value is
#' \code{acc_to_delta(.75)}}
#'
#' \item{delta_sd}{is na optional vector specifying standard deviations of
#' independent normal priors on delta fixed effects. This must be of the same
#' length as the number of delta fixed effects or of length 1, in which case the
#' same value will be used for every delta fixed effect. The default value is
#' \code{.5 * (acc_to_delta(.99) - acc_to_delta(.51))}}
#'
#' \item{gamma_mu}{is na optional vector specifying means of independent normal
#' priors on gamma fixed effects. This must be of the same length as the number
#' of gamma fixed effects or of length 1, in which case the same value will be
#' used for every gamma fixed effect. Note that when there is more than one
#' criterion the number of gamma fixed effects is equal to the number I of
#' columns of gamma fixed effects model matrix times the number of criteria C.
#' Internally, \code{gamma_mu} is stored as a CxI matrix (in column major
#' order): element C*j+i of the \code{gamma_mu} vector (where 0 < j and 0 < i <
#' C) represents fixed effect corresponding to the i-th column of the gamma
#' fixed effects model matrix and the j-th criterion. The default value is 0.}
#'
#' \item{gamma_sd}{is na optional vector specifying standard deviations of
#' independent normal priors on gamma fixed effects. This must be of the same
#' length as the number of gamma fixed effects or of length 1, in which case the
#' same value will be used for every gamma fixed effect. See \code{gamma_mu}
#' above for details on how the elements of the \code{gamma_sd} vector
#' correspond to elements of the gamma fixed effects parameter matrix. The
#' default value is log(100) which means that a priori areas under the
#' gamma-to-criterion mapping distribution curve delineated by the criteria are
#' expected to vary by a factor of 100 or less but varying by a factor of
#' \code{exp(2*log(100)) = 10000} is highly unlikely.}
#'
#' }
#'
#' \code{random} is on optional list of lists of model formulae and prior
#' parameter values, if non-default priors on random effects are required. Each
#' list specifies delta and gamma random effects of one grouping factor:
#'
#' \describe{
#'
#' \item{group}{is a model formula specifying the random grouping factor, e.g.,
#' \code{group = ~ subject}}
#'
#' \item{delta}{is a model formula that defines the delta random effects model
#' matrix. This must define a submodel of the delta fixed effects model, e.g.,
#' if delta depends on condition and condition is a within-subject variable then
#' \code{delta = ~ condition} is a valid delta random effects specification.}
#'
#' \item{gamma}{is a model formula that defines the gamma random effects model
#' matrix. This must define a submodel of the gamma fixed effects model, e.g.,
#' if gamma depends on condition and condition is a within-subject variable then
#' \code{gamma = ~ condition} is a valid gamma random effects specification.}
#'
#' \item{delta_nu}{is an optional vector of lkj prior parameters for delta
#' random effects. This must be of the same length as the number of delta random
#' effects or of length 1, in which case the same value will be used for every
#' delta random effect. The default is 1 which corresponds to uniform prior on
#' random effects correlation matrices. The greater the value of this parameter
#' the more emphasis is put on zer off-diagonal correlations.}
#'
#' \item{delta_sd_scale}{is an optional vector of half-Cauchy prior parameters
#' for delta random effects. This must be of the same length as the number of
#' delta random effects or of length 1, in which case the same value will be
#' used for every delta random effect. The default value is \code{.5 *
#' (acc_to_delta(.99) - acc_to_delta(.51))}}
#'
#' \item{gamma_nu}{is an optional vector of lkj prior parameters for gamma
#' random effects. This must be of the same length as the number of gamma random
#' effects or of length 1, in which case the same value will be used for every
#' gamma random effect. The default is 1 which corresponds to uniform prior on
#' random effects correlation matrices. The greater the value of this parameter
#' the more emphasis is put on zer off-diagonal correlations. See
#' \code{gamma_mu} above for details on how the elements of the \code{gamma}
#' vector correspond to elements of the gamma parameter matrix.}
#'
#' \item{gamma_sd_scale}{is an optional vector of half-Cauchy prior parameters
#' for gamma random effects. This must be of the same length as the number of
#' gamma random effects or of length 1, in which case the same value will be
#' used for every gamma random effect. The default value is \code{log(100)}. See
#' \code{gamma_mu} above for details on how the elements of the \code{gamma}
#' vector correspond to elements of the gamma parameter matrix.}
#'
#' }
#'
#' @param adata an aggregated data object created by
#'     \code{aggregate_responses} function.
#' @param fixed a list specifying gamma and delta fixed effects and
#'     priors. See also 'Details'.
#' @param random an optional list specifying gamma and delta random
#'     effects and priors. The default is list(), which corresponds to
#'     a non-hierarchical SDT model. See also 'Details'.
#' @param criteria_scale a scaling factor corresponding to mapping
#'     distribution's standard deviation, applies only to the softmax
#'     gamma link function. The default is 2. See also 'Details'.
#' @param gamma_link is either 'softmax' (described in the paper),
#'     'log_distance' or 'log_ratio' (See the Readme file in the
#'     github repository)
#' @param metad when TRUE additional data required by the meta-d'
#'     model are created, the default if FALSE.
#' @return a list with response and stimulus data, model matrices,
#'     prior parameter values, and other data required by the stan
#'     model generated using \code{make_stan_model}.
#' @examples
#' data(gabor)
#' gabor$r = combined_response(gabor$stim, gabor$rating, gabor$acc)
#' adata = aggregate_responses(gabor, 'stim', 'r', c('duration', 'id', 'order'))
#' fixed = list(delta = ~ -1 + duration:order, gamma = ~ order)
#' random = list(list(group = ~ id, delta = ~ -1 + duration, gamma = ~ 1))
#' sdata = make_stan_data(adata, fixed, random)
#' sdata
#' @export
make_stan_data = function(adata, fixed, random = list(), criteria_scale = 2, gamma_link = 'softmax', metad = FALSE){
    if(!(gamma_link %in% c('softmax', 'log_ratio', 'log_distance')))
        stop("The link function must be one of the following: 'softmax', 'log_ratio', 'log_distance'")
    if(gamma_link != 'softmax'){
        default_gamma_scale = default_gamma_sd = 2
    }else{
        warning("When using the log_distance or the log_ratio link functions it may be necessary
to set the init_r argument of the stan function to a value lower than 2 (the default), e.g., .5.
This limits the range of initial values.")
        default_gamma_scale = default_gamma_sd = log(100)
    }
    K = ncol(adata$counts)
    if(length(random) > 0){
        for(l in 1:length(random)){
            group.mm = stats::model.matrix(random[[l]]$group, adata$data)
            if(ncol(group.mm) == 2){
                ## Probably a numeric variable
                random[[l]]$group = as.numeric(as.factor(as.character(group.mm[,2])))
            }else{
                ## Probably a factor
                group.mm = remove.zero.cols(group.mm)
                random[[l]]$group = (group.mm %*% 1:(ncol(group.mm)))[,1]
            }
        }
    }
    X_delta = remove.zero.cols(stats::model.matrix(fixed$delta, adata$data))
    X_gamma = remove.zero.cols(stats::model.matrix(fixed$gamma, adata$data))
    data = list(N = nrow(X_delta),
                K = K,
                X_delta_ncol = ncol(X_delta),
                X_delta = X_delta,
                X_gamma_ncol = ncol(X_gamma),
                X_gamma = X_gamma,
                criteria_scale = criteria_scale,
                ## stim_sign = -1, 1
                stim_sign = 2 * as.numeric(as.factor(as.character(adata$stimulus))) - 3,
                counts = adata$counts)
    ## Priors
    if(!metad){
        data$delta_fixed_mu = parse_prior(fixed$delta_mu, acc_to_delta(.75), ncol(X_delta), 'delta_mu')
        data$delta_fixed_sd = parse_prior(fixed$delta_sd, .5 * (acc_to_delta(.99) - acc_to_delta(.51)), ncol(X_delta), 'delta_sd')
    }else{
        data$delta_fixed_mu = parse_prior(fixed$delta_mu, acc_to_delta(.75), c(2, ncol(X_delta)), 'delta_mu')
        data$delta_fixed_sd = parse_prior(fixed$delta_sd, .5 * (acc_to_delta(.99) - acc_to_delta(.51)), c(2, ncol(X_delta)), 'delta_sd')
    }
    data$gamma_fixed_mu = parse_prior(fixed$gamma_mu, 0, c(K - 1, ncol(X_gamma)), 'gamma_mu')
    data$gamma_fixed_sd = parse_prior(fixed$gamma_sd, default_gamma_sd, c(K - 1, ncol(X_gamma)), 'gamma_sd')
    ## Random effects
    if(length(random) > 0){
        for(l in 1:length(random)){
            data[[sprintf('G_%d', l)]] = max(random[[l]]$group)
            data[[sprintf('group_%d', l)]] = random[[l]]$group
            if(!is.null(random[[l]]$delta)){
                mm = remove.zero.cols(stats::model.matrix(random[[l]]$delta, adata$data))
                data[[sprintf('Z_delta_ncol_%d', l)]] = ncol(mm)
                data[[sprintf('Z_delta_%d', l)]] = mm
                data[[sprintf('lkj_delta_nu_%d', l)]] = if(is.null(random[[l]]$delta_nu)){ 1 }else{ random[[l]]$delta_nu }
                if(is.null(random[[l]]$delta_scale)){
                    if(!metad){
                        delta_sd_scale = rep(.5 * (acc_to_delta(.99) - acc_to_delta(.51)), ncol(mm))
                    }else{
                        delta_sd_scale = rep(.5 * (acc_to_delta(.99) - acc_to_delta(.51)), 2 * ncol(mm))
                    }
                }else{
                    if(length(random[[l]]$delta_scale) == 1){
                        if(!metad){
                            delta_sd_scale = rep(random[[l]]$delta_scale[1], ncol(mm))
                        }else{
                            delta_sd_scale = rep(random[[l]]$delta_scale[1], 2 * ncol(mm))
                        }
                    }else{
                        delta_sd_scale = random[[l]]$delta_scale
                    }
                }
                data[[sprintf('delta_sd_scale_%d', l)]] = fix_stan_dim(delta_sd_scale)
            }
            if(!is.null(random[[l]]$gamma)){
                mm = remove.zero.cols(stats::model.matrix(random[[l]]$gamma, adata$data))
                data[[sprintf('Z_gamma_ncol_%d', l)]] = ncol(mm)
                data[[sprintf('Z_gamma_%d', l)]] = mm
                data[[sprintf('lkj_gamma_nu_%d', l)]] = if(is.null(random[[l]]$gamma_nu)){ 1 }else{ random[[l]]$gamma_nu }
                if(is.null(random[[l]]$gamma_scale)){
                    gamma_sd_scale = rep(default_gamma_scale, (K - 1) * ncol(mm))
                }else{
                    if(length(random[[l]]$gamma_scale) == 1){
                        gamma_sd_scale = rep(random[[l]]$gamma_scale[1], (K - 1) * ncol(mm))
                    }else{
                        gamma_sd_scale = random[[l]]$gamma_scale
                    }
                }
                data[[sprintf('gamma_sd_scale_%d', l)]] = fix_stan_dim(gamma_sd_scale)
            }
        }
    }
    data
}

fix_stan_dim = function(x)if(length(x) == 1){ array(x, dim = 1) }else{ x }

remove.zero.cols = function(m)as.matrix(m[,apply(m, 2, function(x)!all(x == 0))])

parse_prior = function(value = NULL, default, dims, name){
  if(is.null(value)){
    if(length(dims) == 1){
      value = rep(default, dims)
    }else{
      value = matrix(default, nrow = dims[1], ncol = dims[2])
    }
  }else{
    if(length(value) == 1){
      if(length(dims) == 1){
        value = rep(value, dims)
      }else{
        value = matrix(value, nrow = dims[1], ncol = dims[2])
      }
    }else{
      if(length(value) != prod(dims))
        stop(sprintf("Prior specification %s must contain 1 or %d elements", name, dims))
    }
  }
  fix_stan_dim(value)
}
